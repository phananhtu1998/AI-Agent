<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>A2A Chat</title>
    <style>
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 0; background: #0b1020; color: #e8ecf1; }
      header { padding: 12px 16px; border-bottom: 1px solid #223; background: #0f152b; position: sticky; top: 0; }
      main { display: grid; grid-template-rows: 1fr auto; height: 100vh; }
      #log { padding: 16px; overflow-y: auto; }
      .msg { padding: 10px 12px; border-radius: 10px; margin: 8px 0; max-width: 80%; white-space: pre-wrap; word-break: break-word; }
      .user { background: #1e2a4a; margin-left: auto; }
      .agent { background: #162036; margin-right: auto; }
      form { display: flex; gap: 8px; padding: 12px 16px; border-top: 1px solid #223; background: #0f152b; }
      input[type="text"] { flex: 1; padding: 10px 12px; border-radius: 8px; border: 1px solid #334; background: #0c142b; color: #e8ecf1; }
      button { padding: 10px 14px; border-radius: 8px; border: 1px solid #3a5; background: #1a3; color: white; cursor: pointer; }
      button:disabled { opacity: 0.6; cursor: not-allowed; }
      .meta { color: #8aa; font-size: 12px; margin-top: 2px; }
      .typing-indicator { display: none; padding: 10px 12px; border-radius: 10px; margin: 8px 0; max-width: 80%; background: #162036; margin-right: auto; }
      .typing-dots { display: inline-flex; align-items: center; gap: 4px; }
      .typing-dot { width: 8px; height: 8px; border-radius: 50%; background: #8aa; animation: typing 1.4s infinite ease-in-out; }
      .typing-dot:nth-child(1) { animation-delay: -0.32s; }
      .typing-dot:nth-child(2) { animation-delay: -0.16s; }
      @keyframes typing { 0%, 80%, 100% { transform: scale(0.8); opacity: 0.5; } 40% { transform: scale(1); opacity: 1; } }
    </style>
  </head>
  <body>
    <main>
      <header>
        <strong>A2A Chat</strong>
        <div class="meta">POST /.well-known endpoints available; RPC at /</div>
      </header>
      <div id="log"></div>
      <div id="typing-indicator" class="typing-indicator">
        <div class="typing-dots">
          <div class="typing-dot"></div>
          <div class="typing-dot"></div>
          <div class="typing-dot"></div>
        </div>
      </div>
      <form id="chat-form">
        <input id="text" type="text" placeholder="Type a message..." autocomplete="off" />
        <button id="send" type="submit">Send</button>
        <button id="stream" type="button">Stream</button>
      </form>
    </main>
    <script>
      const log = document.getElementById('log');
      const form = document.getElementById('chat-form');
      const input = document.getElementById('text');
      const sendBtn = document.getElementById('send');
      const streamBtn = document.getElementById('stream');
      const typingIndicator = document.getElementById('typing-indicator');

      // Support both http:// and file:// usage
      const API_BASE = location.protocol === 'file:' ? 'http://localhost:9999' : '';

      function showTypingIndicator() {
        typingIndicator.style.display = 'block';
        log.scrollTop = log.scrollHeight;
      }

      function hideTypingIndicator() {
        typingIndicator.style.display = 'none';
      }

      function addMessage(role, text) {
        const div = document.createElement('div');
        div.className = `msg ${role === 'user' ? 'user' : 'agent'}`;
        div.textContent = text;
        log.appendChild(div);
        log.scrollTop = log.scrollHeight;
      }

      function uuid() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
          const r = (crypto.getRandomValues(new Uint8Array(1))[0] & 0xf) >> 0;
          const v = c === 'x' ? r : (r & 0x3) | 0x8;
          return v.toString(16);
        });
      }

      async function sendMessage(text) {
        showTypingIndicator();
        const body = {
          id: uuid(),
          jsonrpc: '2.0',
          method: 'message/send',
          params: {
            message: {
              kind: 'message',
              messageId: uuid(),
              role: 'user',
              parts: [{ kind: 'text', text }]
            },
            configuration: { blocking: true, historyLength: 0 }
          }
        };
        const res = await fetch(`${API_BASE}/`, {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify(body)
        });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const data = await res.json();
        hideTypingIndicator();
        // Show either a direct Message result or a Task wrapper
        const result = data.result || {};
        if (result.kind === 'message') {
          const parts = (result.parts || []).filter(p => p.kind === 'text');
          addMessage('agent', parts.map(p => p.text).join('\n'));
        } else if (result.kind === 'task') {
          const status = result.status || {};
          if (status.message && Array.isArray(status.message.parts)) {
            const parts = status.message.parts.filter(p => p.kind === 'text');
            addMessage('agent', parts.map(p => p.text).join('\n'));
          } else {
            addMessage('agent', JSON.stringify(result));
          }
        } else if (data.error) {
          addMessage('agent', 'Error: ' + (data.error.message || 'unknown'));
        } else {
          addMessage('agent', JSON.stringify(data));
        }
      }

      async function streamMessage(text) {
        showTypingIndicator();
        const body = {
          id: uuid(),
          jsonrpc: '2.0',
          method: 'message/stream',
          params: {
            message: {
              kind: 'message',
              messageId: uuid(),
              role: 'user',
              parts: [{ kind: 'text', text }]
            },
            configuration: { historyLength: 0 }
          }
        };

        const res = await fetch(`${API_BASE}/`, {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify(body)
        });
        if (!res.ok || !res.body) {
          hideTypingIndicator();
          throw new Error('Streaming HTTP ' + res.status);
        }

        const reader = res.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        let hasReceivedData = false;
        const processBuffer = () => {
          // SSE events are separated by double newlines
          const events = buffer.split(/\n\n/);
          // keep the last partial chunk in buffer
          buffer = events.pop() || '';
          for (const evt of events) {
            const lines = evt.split(/\n/);
            const dataLines = lines.filter(l => l.startsWith('data:'))
                                   .map(l => l.slice(5).trim())
                                   .join('\n');
            if (dataLines) {
              try {
                const payload = JSON.parse(dataLines);
                if (payload.type === 'agent_text_message' && payload.payload && payload.payload.text) {
                  if (!hasReceivedData) {
                    hideTypingIndicator();
                    hasReceivedData = true;
                  }
                  addMessage('agent', payload.payload.text);
                }
                // Stop reading if we see a terminal event shape
                if (payload.type === 'task_completed' || payload.type === 'stream_end') {
                  return true; // signal to stop
                }
              } catch (_) {
                // ignore malformed JSON chunks
              }
            }
          }
          return false;
        };

        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          buffer += decoder.decode(value, { stream: true });
          const shouldStop = processBuffer();
          if (shouldStop) break;
        }
        // Flush any remaining buffered event
        buffer += decoder.decode();
        processBuffer();
        // Ensure typing indicator is hidden at the end
        hideTypingIndicator();
      }

      form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const text = input.value.trim();
        if (!text) return;
        addMessage('user', text);
        input.value = '';
        sendBtn.disabled = true; streamBtn.disabled = true;
        try {
          await sendMessage(text);
        } catch (err) {
          hideTypingIndicator();
          addMessage('agent', 'Error: ' + err.message);
        } finally {
          sendBtn.disabled = false; streamBtn.disabled = false;
        }
      });

      streamBtn.addEventListener('click', async () => {
        const text = input.value.trim();
        if (!text) return;
        addMessage('user', text);
        input.value = '';
        streamBtn.disabled = true; sendBtn.disabled = true;
        try {
          await streamMessage(text);
        } catch (err) {
          hideTypingIndicator();
          addMessage('agent', 'Stream error: ' + err.message);
        } finally {
          streamBtn.disabled = false; sendBtn.disabled = false;
        }
      });
    </script>
  </body>
  </html>


